#version 430

layout(local_size_x = 8, local_size_y = 8) in;
layout(rgba8, binding = 0) uniform image2D outputImage;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Triangle {
    vec3 v0, v1, v2;
    vec3 normal;
    vec3 color;
    float reflectivity;
};

struct BVHNode {
    vec3 minBounds;
    vec3 maxBounds;
    int leftChild;
    int rightChild;
    int triangleStart;
    int triangleCount;
};

layout(std430, binding = 1) buffer TriangleBuffer {
    Triangle triangles[];
};

layout(std430, binding = 2) buffer BVHBuffer {
    BVHNode bvhNodes[];
};

uniform vec3 cameraPos;
uniform vec3 cameraTarget;
uniform vec3 cameraUp;
uniform float fov;
uniform vec3 lightPos;
uniform vec3 lightColor;
uniform int maxBounces;

const float EPSILON = 0.001;
const float PI = 3.14159265359;

bool rayBoxIntersect(Ray ray, vec3 boxMin, vec3 boxMax) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t1 = (boxMin - ray.origin) * invDir;
    vec3 t2 = (boxMax - ray.origin) * invDir;
    
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar = min(min(tMax.x, tMax.y), tMax.z);
    
    return tNear <= tFar && tFar > 0.0;
}

bool rayTriangleIntersect(Ray ray, Triangle tri, out float t, out vec3 hitPoint) {
    vec3 edge1 = tri.v1 - tri.v0;
    vec3 edge2 = tri.v2 - tri.v0;
    vec3 h = cross(ray.direction, edge2);
    float a = dot(edge1, h);
    
    if (a > -EPSILON && a < EPSILON) {
        return false;
    }
    
    float f = 1.0 / a;
    vec3 s = ray.origin - tri.v0;
    float u = f * dot(s, h);
    
    if (u < 0.0 || u > 1.0) {
        return false;
    }
    
    vec3 q = cross(s, edge1);
    float v = f * dot(ray.direction, q);
    
    if (v < 0.0 || u + v > 1.0) {
        return false;
    }
    
    t = f * dot(edge2, q);
    
    if (t > EPSILON) {
        hitPoint = ray.origin + ray.direction * t;
        return true;
    }
    
    return false;
}

bool traverseBVH(Ray ray, out float closestT, out Triangle closestTriangle, out vec3 hitPoint) {
    closestT = 1e30;
    bool hit = false;
    
    int stack[64];
    int stackPtr = 0;
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0) {
        int nodeIndex = stack[--stackPtr];
        BVHNode node = bvhNodes[nodeIndex];
        
        if (!rayBoxIntersect(ray, node.minBounds, node.maxBounds)) {
            continue;
        }
        
        if (node.triangleCount > 0) {
            for (int i = 0; i < node.triangleCount; i++) {
                Triangle tri = triangles[node.triangleStart + i];
                float t;
                vec3 hp;
                
                if (rayTriangleIntersect(ray, tri, t, hp) && t < closestT) {
                    closestT = t;
                    closestTriangle = tri;
                    hitPoint = hp;
                    hit = true;
                }
            }
        } else {
            if (node.leftChild >= 0) stack[stackPtr++] = node.leftChild;
            if (node.rightChild >= 0) stack[stackPtr++] = node.rightChild;
        }
    }
    
    return hit;
}

vec3 calculateLighting(vec3 hitPoint, vec3 normal, vec3 color, vec3 viewDir) {
    vec3 lightDir = normalize(lightPos - hitPoint);
    
    Ray shadowRay;
    shadowRay.origin = hitPoint + normal * EPSILON;
    shadowRay.direction = lightDir;
    
    float shadowT;
    Triangle shadowTri;
    vec3 shadowHit;
    bool inShadow = traverseBVH(shadowRay, shadowT, shadowTri, shadowHit);
    
    float shadow = inShadow ? 0.3 : 1.0;
    
    vec3 ambient = color * 0.1;
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = color * diff * lightColor * shadow;
    
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
    vec3 specular = lightColor * spec * shadow * 0.5;
    
    return ambient + diffuse + specular;
}

vec3 traceRay(Ray ray, int depth) {
    if (depth >= maxBounces) {
        return vec3(0.2, 0.3, 0.3);
    }
    
    float t;
    Triangle tri;
    vec3 hitPoint;
    
    if (!traverseBVH(ray, t, tri, hitPoint)) {
        float skyT = 0.5 * (ray.direction.y + 1.0);
        return mix(vec3(1.0, 1.0, 1.0), vec3(0.5, 0.7, 1.0), skyT);
    }
    
    vec3 normal = normalize(tri.normal);
    vec3 viewDir = -ray.direction;
    vec3 color = calculateLighting(hitPoint, normal, tri.color, viewDir);
    
    if (tri.reflectivity > 0.0) {
        vec3 reflectDir = reflect(ray.direction, normal);
        Ray reflectRay;
        reflectRay.origin = hitPoint + normal * EPSILON;
        reflectRay.direction = reflectDir;
        
        vec3 reflectColor = traceRay(reflectRay, depth + 1);
        color = mix(color, reflectColor, tri.reflectivity);
    }
    
    return color;
}

Ray getCameraRay(vec2 uv) {
    float aspect = float(gl_NumWorkGroups.x * gl_WorkGroupSize.x) / float(gl_NumWorkGroups.y * gl_WorkGroupSize.y);
    float theta = fov * PI / 180.0;
    float halfHeight = tan(theta / 2.0);
    float halfWidth = aspect * halfHeight;
    
    vec3 w = normalize(cameraPos - cameraTarget);
    vec3 u = normalize(cross(cameraUp, w));
    vec3 v = cross(w, u);
    
    vec3 lowerLeftCorner = cameraPos - halfWidth * u - halfHeight * v - w;
    vec3 horizontal = 2.0 * halfWidth * u;
    vec3 vertical = 2.0 * halfHeight * v;
    
    Ray ray;
    ray.origin = cameraPos;
    ray.direction = normalize(lowerLeftCorner + uv.x * horizontal + uv.y * vertical - cameraPos);
    
    return ray;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(outputImage);
    
    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) {
        return;
    }
    
    vec2 uv = (vec2(pixelCoords) + 0.5) / vec2(imageSize);
    Ray ray = getCameraRay(uv);
    
    vec3 color = traceRay(ray, 0);
    
    color = sqrt(clamp(color, 0.0, 1.0));
    
    imageStore(outputImage, pixelCoords, vec4(color, 1.0));
}
