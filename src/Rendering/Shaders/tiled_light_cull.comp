#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(std430, binding = 0) buffer LightGrid { ivec2 grid[]; };
layout(std430, binding = 1) buffer LightIndex { int indices[]; };

uniform ivec2 screenSize;
uniform int numLights;

// Uploaded from CPU (subset up to 128)
uniform vec3 lightPositions[128];
uniform float lightRanges[128];
uniform int lightTypes[128];

shared uint countShared;

bool lightAffectsTile(int li, ivec2 tile, int tileSize) {
    if (li < 0 || li >= numLights) return false;
    int type = lightTypes[li];
    if (type == 0) {
        return true;
    }
    vec2 tileMin = vec2(tile * tileSize);
    vec2 tileMax = tileMin + vec2(tileSize);

    vec2 lp = lightPositions[li].xy;
    float r = lightRanges[li];
    vec2 closest = clamp(lp, tileMin, tileMax);
    float d2 = dot(lp - closest, lp - closest);
    return d2 <= (r * r);
}

void main() {
    ivec2 tile = ivec2(gl_WorkGroupID.xy);
    int tilesX = (screenSize.x + 15) / 16;
    int tileIndex = tile.y * max(tilesX, 1) + tile.x;
    if (tileIndex < 0) return;

    int base = tileIndex * 256;

    if (gl_LocalInvocationIndex == 0u) {
        countShared = 0u;
    }
    memoryBarrierShared();
    barrier();

    for (int i = int(gl_LocalInvocationIndex); i < min(numLights, 128); i += int(gl_WorkGroupSize.x * gl_WorkGroupSize.y)) {
        if (lightAffectsTile(i, tile, 16)) {
            uint dst = atomicAdd(countShared, 1u);
            if (dst < 256u) {
                indices[base + int(dst)] = i;
            }
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0u) {
        uint c = min(countShared, 256u);
        grid[tileIndex] = ivec2(base, int(c));
        for (uint j = c; j < 256u; ++j) {
            indices[base + int(j)] = -1;
        }
    }
}
