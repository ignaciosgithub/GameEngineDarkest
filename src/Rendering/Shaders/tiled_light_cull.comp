#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(std430, binding = 0) buffer LightGrid { ivec2 grid[]; }; 
layout(std430, binding = 1) buffer LightIndex { int indices[]; };

uniform ivec2 screenSize;
uniform int numLights;

// Uploaded from CPU (subset up to 128)
uniform vec3 lightPositions[128];
uniform float lightRanges[128];
uniform int lightTypes[128];

bool lightAffectsTile(int li, ivec2 tile, int tileSize) {
    if (li < 0 || li >= numLights) return false;
    int type = lightTypes[li];
    if (type == 0) {
        return true;
    }
    vec2 tileMin = vec2(tile * tileSize);
    vec2 tileMax = tileMin + vec2(tileSize);
    vec2 tileCenter = 0.5 * (tileMin + tileMax);

    vec2 lp = lightPositions[li].xy;
    float r = lightRanges[li];
    vec2 closest = clamp(lp, tileMin, tileMax);
    float d2 = dot(lp - closest, lp - closest);
    return d2 <= (r * r);
}

void main() {
    ivec2 tile = ivec2(gl_WorkGroupID.xy);
    int tilesX = (screenSize.x + 15) / 16;
    int tileIndex = tile.y * max(tilesX, 1) + tile.x;
    if (tileIndex < 0) return;

    int base = tileIndex * 256;
    int count = 0;

    for (int i = int(gl_LocalInvocationIndex); i < min(numLights, 128); i += int(gl_WorkGroupSize.x * gl_WorkGroupSize.y)) {
        if (lightAffectsTile(i, tile, 16)) {
            int dst = atomicAdd(count, 1);
            if (dst < 256) {
                indices[base + dst] = i;
            }
        }
    }

    barrier();

    if (gl_LocalInvocationIndex == 0) {
        grid[tileIndex] = ivec2(base, min(count, 256));
        for (int j = count; j < 256; ++j) {
            indices[base + j] = -1;
        }
    }
}
